library(data.table)

####################################################################################################
# Description: chooses a single trim for each Polk observation and supplements with additional 
# vehicle characteristics. You should ignore the part of the code that uses the existing vehicle 
# data (the stuff that runs when bln.vindata = T), but the rest should work for you conditional 
# on getting you all the input files.

####################################################################################################
# Set up
setwd("/Users/rrn22")
str.dir <-  "~/Documents/tobin_working_data/"
str.sp <- paste0(str.dir,'rlpolk_data/')
str.veh <- str.dir
str.noise <- paste0(str.dir,'CT_EVs/Cleaned data/Data/')

# how to choose between trims in S&P data when there are multiple
bln.vindata <- F # this works through 2021, but not longer
# otherwise, choose lower msrp

# CT data vs. other 15 states
state <- 'CT'
# state <- 'top_15'

####################################################################################################
# Read in RLP data
str.ct.zip <- 'ct_zip_sp.csv'
str.ct.decoded <- 'ct_sp_vin_decoded_nonunique.csv'

str.top15.county <- 'top_15_county_sp.csv'
str.top15.decoded <- 'sp_vin_decoded_nonunique.csv'

if(state == 'CT')
{
  dt.sales <- data.table(read.csv(paste0(str.sp,str.ct.zip)))
  dt.decoded <- data.table(read.csv(paste0(str.sp,str.ct.decoded)))
} else
{
  dt.sales <- data.table(read.csv(paste0(str.sp,str.top15.county)))
  dt.decoded <- data.table(read.csv(paste0(str.sp,str.top15.decoded)))
}

if(bln.vindata)
{
  # choose unique make/model/year/fueltype to match with vin data (will default merge with most popular config)
  dt.decoded.keep <- unique(dt.decoded[,.(make,model,model_year,fuel_type,sp_id)])
}

####################################################################################################
# Read in VIN data (from Experian)
if(bln.vindata)
{
  str.vin.data <- 'intermediate/agg_US_VIN_data_common.csv'
  dt.vin.data <- data.table(read.csv(paste0(str.veh,str.vin.data)))
}

####################################################################################################
# read EPA data, crosswalks
# original EPA data (used through 21)
str.epa <- 'raw/fuel_economy/vehicles.csv'
dt.epa <- data.table(read.csv(paste0(str.veh,str.epa)))
# new EPA data (22+)
print("We do not have the 2022+ EPA data vehicles_23.csv")
str.epa.22 <- 'raw/fuel_economy/vehicles_23.csv'
dt.epa.22 <- data.table(read.csv(paste0(str.veh,str.epa.22)))

# data through 2021 crosswalks
# generated by merge_EPA_fe_range_data.R
str.cw.ev <- 'intermediate/data_crosswalk/vin_EPA_fe_crosswalk.csv'
dt.cw.ev <- data.table(read.csv(paste0(str.veh,str.cw.ev)))

str.cw.ev.tesla <- 'intermediate/data_crosswalk/vin_EPA_fe_crosswalk_tesla.csv'
dt.cw.ev.tesla <- data.table(read.csv(paste0(str.veh,str.cw.ev.tesla)))

# 2022 (and some 2023) crosswalks
# generated by merge_epa_data_22.R
str.cw.ev.22 <- 'intermediate/data_crosswalk/vin_EPA_fe_2022_crosswalk.csv'
dt.cw.22 <- data.table(read.csv(paste0(str.veh,str.cw.ev.22)))

str.cw.ev.missing.22 <- 'intermediate/data_crosswalk/vin_EPA_fe_2022_missing_crosswalk.csv'
dt.cw.missing.22 <- data.table(read.csv(paste0(str.veh,str.cw.ev.missing.22)))

# read federal EV incentive data
# generated by merge_fed_incentives.R
str.fed.nonphaseout <- 'intermediate/federal_incentive_cleaned_nonphaseout.csv'
dt.fed.nonphaseout <- data.table(read.csv(paste0(str.veh,str.fed.nonphaseout)))
str.fed.phaseout <- 'intermediate/federal_incentive_cleaned_phaseout.csv'
dt.fed.phaseout <- data.table(read.csv(paste0(str.veh,str.fed.phaseout)))
str.fed.cw <- 'intermediate/data_crosswalk/vin_federal_incentive_crosswalk.csv'
dt.fed.cw <- data.table(read.csv(paste0(str.veh,str.fed.cw)))

# read ZEV credit data
str.zev.credits <- 'intermediate/ZEV_credits.csv'
dt.zev.credits <- data.table(read.csv(paste0(str.veh,str.zev.credits)))

# read in battery size data
str.battery <- 'intermediate/ev_model_style_trim_battery.csv'
dt.battery <- data.table(read.csv(paste0(str.veh,str.battery)))

# includes some 2022 vehicles that didn't show up in previous data
str.battery23 <- 'intermediate/ev_model_style_trim_battery_23.csv'
dt.battery23 <- data.table(read.csv(paste0(str.veh,str.battery23)))

####################################################################################################
# Functions
# clean data ----
clean_drivetype <- function(dt)
{
  dt[drive_type %in% c('4X4','4x4','AWD'),drive_type:='Awd']
  dt[drive_type %in% c('2wd','4X2','Fwd','FWD','Rwd','RWD'),drive_type:='2wd']
  return(dt)
}
## clean sales data (drop heavy duty vehicles) ----
l1 = nrow(dt.sales)
dt.sales <- dt.sales[!(make %in% c('Ic Corp','Freightliner','Western Star','Kenworth','Peterbilt','Pierce','Hino','International','Autocar','Mack','Thomas Built Buses','Kalmar','Oshkosh','Temsa','Capacity Of Texas','Advance Mixer','Mitsubishi Fuso','Emergency One','Spartan Motors'))]
l2 = nrow(dt.sales)
print(paste0('Dropped ',l1-l2,' heavy duty vehicles'))


## merge EPA range data with crosswalk ----
# through 2021 cw
dt.cw.ev.all <- rbind(dt.cw.ev,dt.cw.ev.tesla)
dt.epa.rangefe <- unique(dt.epa[,.(atvType,make,model,year,cylinders,displ,drive,comb08,combA08,combE,range,rangeA,cityUF,highwayUF,combinedUF,city08,cityA08,highway08,highwayA08,UCity,UCityA,UHighway,UHighwayA)])
setnames(dt.epa.rangefe,c('make','model'),c('make_epa_orig','model_epa_orig'))

dt.epa.range <- merge(dt.epa.rangefe[atvType %in% c('Plug-in Hybrid','EV')],
                      dt.cw.ev.all,
                      by=c('make_epa_orig','model_epa_orig','year'),
                      all.y=T)
                      
print("We lack the file vehicles_23.csv, so we cannot merge the 2022+ EPA data with the crosswalk")
if(TRUE){
  # 2022+ main cw
  dt.epa.rangefe.22 <- unique(dt.epa.22[,.(atvType,make,model,year,cylinders,displ,drive,comb08,combA08,combE,range,rangeA,cityUF,highwayUF,combinedUF,city08,cityA08,highway08,highwayA08,UCity,UCityA,UHighway,UHighwayA)])
  setnames(dt.epa.rangefe.22,c('make','model'),c('make_epa_orig','model_epa_orig'))
  dt.epa.range.22 <- merge(dt.epa.rangefe.22[atvType %in% c('Plug-in Hybrid','EV')],
                          dt.cw.22,
                          by=c('make_epa_orig','model_epa_orig','year'),
                          all.y=T)

  # (small) 2022+ missing vehicles cw
  setnames(dt.epa.rangefe.22,c('year'),c('year_epa_orig'))
  dt.epa.range.missing <- merge(dt.epa.rangefe.22,
                                dt.cw.missing.22,
                                by=c('make_epa_orig','year_epa_orig','model_epa_orig'))

  # combine decoded range
  dt.epa.range.22 <- rbindlist(list(dt.epa.range.22,dt.epa.range.missing[,!c('year_epa_orig'),with=F]),
                            use.names=T)
  setnames(dt.epa.range.22,c('body_type','drive_type','fuel_type'),c('bodytype','drivetype','fueltype'))
  dt.epa.range <- rbind(dt.epa.range,dt.epa.range.22)
  dt.epa.range[,range_elec:=ifelse(atvType == 'EV',range,rangeA)]
  dt.epa.range[make == 'Mercedes-Benz',make:= 'Mercedes']


  ## merge fed incentive data with crosswalk ----
  clean_fed_inc <- function (dt.fed,dt.cw)
  {
    setnames(dt.fed,'model','model_inc_orig')
    dt.fed <- merge(dt.fed,
                    dt.cw,
                    by=c('make','model_inc_orig','year'))
    setnames(dt.fed,c('model_vin_orig','year','fueltype'),c('model','model_year','fuel_type'))
    return(unique(dt.fed[,!c('model_inc_orig'),with=F]))
  }
  dt.fed.nonphaseout <- clean_fed_inc(dt.fed.nonphaseout,dt.fed.cw)
  setnames(dt.fed.nonphaseout,'credit','fed_credit')
  dt.fed.phaseout <- clean_fed_inc(dt.fed.phaseout,dt.fed.cw)
  # convert phaseout dates to date objects
  dt.fed.phaseout[,c("L2.Start","L3.Start","Final.Start") := lapply(.SD,function(y) as.Date(y)),
                  .SDcols = c("L2.Start","L3.Start","Final.Start")]

  ## clean VIN data (if using) ----
  if(bln.vindata)
  {
    # some EV/PHEVs have multiple make/model/year/fueltype observations because they come in 2 battery size/ranges
    # choose the more popular configuration
    dt.ev.data <- dt.vin.data[fueltype %in% c('L','I')]
    dt.ev.data <- dt.ev.data[,.(ct=sum(agg_count)),
                            by=c('make','model','year','fueltype','style','trim','msrp','range_elec','batterysize','vehicletype','bodytype','drivetype','cityUF','highwayUF','combinedUF')]
    dt.ev.keep <- dt.ev.data[,.(ct=max(ct)),by=c('make','model','year','fueltype')]
    dt.ev.keep[,keep:=1]
    dt.ev.data <- merge(dt.ev.data,
                        dt.ev.keep,
                        by=c('make','model','year','fueltype','ct'),
                        all.x=T)
    dt.ev.data <- dt.ev.data[!is.na(keep)]
    
    # keep only relevant info
    dt.vin.data <- unique(dt.vin.data[!(fueltype %in% c('L','I')),.(make,model,year,fueltype,trim,style,msrp,range_elec,batterysize,vehicletype,bodytype,drivetype,cityUF,highwayUF,combinedUF)])
    dt.vin.data <- rbind(dt.vin.data,
                        dt.ev.data[,!c('keep','ct'),with=F])
    dt.vin.data[,vin_id:=1:nrow(dt.vin.data)]
    setnames(dt.vin.data,c('year','fueltype'),c('model_year','fuel_type'))
  }

  ## clean ZEV credit data ----
  # rename ZEV credit colname
  setnames(dt.zev.credits,c('fueltype','year'),c('fuel_type','model_year'))

  if(bln.vindata)
  {
    # rename drivetype to be consistent with cleaned vin data 
    dt.zev.credits[drivetype %in% c('4X4'),drivetype:='Awd']
    dt.zev.credits[drivetype %in% c('4X2','Fwd','Rwd'),drivetype:='2wd']
    # change a few bodytypes/trims to match cleaned vin data
    dt.zev.credits[make == 'Subaru' & model == 'Crosstrek',bodytype:='SUV']
    dt.zev.credits[make == 'Tesla' & model == 'Model-S' & model_year== 2021 & trim == 'Long Range Plus', 
                  `:=`(trim= 'Long Range',style='AWD Long Range 4dr Liftback')]
    dt.zev.credits[make == 'Tesla' & model == 'Model-Y' & model_year %in%  c(2020,2021),bodytype:= 'SUV']
    dt.zev.credits[make == 'Volkswagen' & model == 'Id.4' & model_year== 2021, bodytype:= 'SUV']
  } else
  {
    setnames(dt.zev.credits,c('bodytype','drivetype'),c('body_type','drive_type'))
    dt.zev.credits <- clean_drivetype(dt.zev.credits)
  }

  ## clean battery data ----
  setnames(dt.battery, c('year','vehicletype','bodytype','drivetype','fueltype'),
          c('model_year','vehicle_type','body_type','drive_type','fuel_type'))
  setnames(dt.battery23, c('year'),c('model_year'))
  dt.battery <- rbind(dt.battery[,!c('X','vehicle_type'),with=F],dt.battery23)
  dt.battery <- clean_drivetype(dt.battery)
  ## clean decoded VIN data ----
  if(! bln.vindata)
  {
    dt.decoded <- clean_drivetype(dt.decoded)
    
    # make fuel type human readable
    dt.decoded[,fuel:=ifelse(fuel_type == 'D','diesel',
                            ifelse(fuel_type == 'L','electric',
                                    ifelse(fuel_type == 'Y','hybrid',
                                          ifelse(fuel_type == 'I','PHEV',
                                                  ifelse(fuel_type == 'G','gasoline',
                                                        ifelse(fuel_type == 'B', 'bio-diesel',
                                                                ifelse(fuel_type == 'F', 'flex fuel', 
                                                                      ifelse(fuel_type == 'H', 'hydrogen',
                                                                              ifelse(fuel_type == 'N', 'nat gas',NA)))))))))]
    
    # fix some make/model names
    dt.decoded[make == 'Mercedes-Benz',make:= 'Mercedes']
    # fix a few names that changed between VIN decoders
    dt.decoded[model == 'Kona-Electric' & model_year < 2022,model:= 'Kona-Ev']
    dt.decoded[make ==  'Audi' & model == 'E-Tron-Sportback' & model_year %in% c(2020,2021),model:= 'E-Tron']
    dt.decoded[make ==  'Fiat' & model == '500e' & model_year %in% c(2017:2019),model:= '500E']
    
    # convert msrp to 1000s
    dt.decoded[,msrp:=msrp/1000]
  }

  # merge S&P with decoder, EPA, battery, and vin data ----
  if(bln.vindata)
  {
    ## merge using pre-cleaned VIN data ----
    # merge decoded vin data with other vehicle data
    dt.decoded.keep <- merge(dt.decoded.keep,
                            dt.vin.data,
                            by=c('make','model','model_year','fuel_type'),
                            all.x=T)
    # some duplicate sp_ids but none of them are in decoded VIN data
    dt.decoded.keep[,.(ct=.N),by=c('sp_id')][ct > 1]
    
    # drop observations not in vin decoded data
    dt.decoded.keep <- dt.decoded.keep[!is.na(vin_id)]
    dt.decoded.keep[,.(ct=.N),by=c('sp_id')][ct > 1]
    
    # merge with observed sales
    dt.sales <- merge(dt.sales[,.(report_year_month,transaction_price,zip_code,county_name,state_abbrv,veh_count,sp_id)],
                      dt.decoded.keep,
                      by=c('sp_id'),
                      all.x=T)
    
    # merge with ZEV credits
    nrow(dt.sales)
    dt.sales <- merge(dt.sales,
                      dt.zev.credits,
                      by=c('make','model','model_year','trim','style','bodytype','drivetype','fuel_type'),
                      all.x=T)
    # fill in NAs as 0
    dt.sales[is.na(zev_credits),zev_credits:=0]
  } else 
  {
    ## merge not using pre-cleaned VIN data ----
    ### merge decoded data with EPA attributes data ----
    # take average range_elec across vehicles with multiple observations in EPA data (this is often due to wheel size)
    #dt.epa.range[,.(ct=.N),by=c('year','make','model_vin_orig','trim','style','bodytype','drivetype','fueltype')][ct > 1]
    dt.epa.range <- dt.epa.range[,.(range_elec = mean(as.numeric(range_elec),na.rm=T)),by=c('year','make','model_vin_orig','trim','style','bodytype','drivetype','fueltype')]
    setnames(dt.epa.range,c('model_vin_orig','year','fueltype','bodytype','drivetype'),c('model','model_year','fuel_type','body_type','drive_type'))
    dt.epa.range <- clean_drivetype(dt.epa.range)
    dt.decoded <- merge(dt.decoded,
                        dt.epa.range,
                        by=c('model_year','make','model','trim','style','body_type','drive_type','fuel_type'),
                        all.x=T)
    # filling in some missing trims
    dt.decoded.fill <- dt.decoded[fuel_type %in% c('I','L'),.(range_elec_fill=mean(range_elec,na.rm=T)),
                                        by=c('model_year','make','model','fuel_type','body_type','drive_type')]
    dt.decoded <- merge(dt.decoded,dt.decoded.fill,
                          by=c('model_year','make','model','fuel_type','body_type','drive_type'),
                          all.x=T)
    dt.decoded[is.na(range_elec) & !is.na(range_elec_fill),range_elec:=range_elec_fill]
    # match remaining missing trim on make/model/fuel type
    dt.epa.range.model <- dt.epa.range[,.(range_elec=mean(range_elec,na.rm=T)),by=c('model_year','make','model','fuel_type')]
    dt.unmatched <- dt.decoded[fuel_type %in% c('I','L') & is.na(range_elec)]
    dt.unmatched <- merge(dt.unmatched[,!c('range_elec')],
                          dt.epa.range.model,
                          by=c('model_year','make','model','fuel_type'),
                          all.x=T)
    # add back to dt.ct.decoded
    dt.decoded <- rbind(dt.decoded[!(is.na(range_elec) & fuel_type %in% c('I','L'))],dt.unmatched)
    dt.decoded <- dt.decoded[,!c('range_elec_fill'),with=F]
    # fill in missing model (wasn't in range data because the VIN doesn't show up in Experian VIN data)
    dt.decoded[is.na(range_elec) & make == 'Mercedes' & model == 'S-Class' & fuel_type == 'I', range_elec:= 19]
    # 0 out non electric vehicles
    dt.decoded[is.na(range_elec) & !(fuel_type %in% c('L','I')),range_elec:=0]
    unique(dt.decoded[is.na(range_elec),.(model_year, make, model, fuel_type)])
    # 2021 Karma Revero, 2022 Gmc Hummer-EV both missing from EPA data
    # ignoring a bunch of Ford E-Transit commercial vehicles

    ### merge decoded data with battery size for EVs ----
    dt.decoded <- merge(dt.decoded,
                        unique(dt.battery[,!c('style')]),
                        by=c('model_year','make','model','fuel_type','body_type','drive_type','trim'),
                        all.x=T)
    # fill in some missing trims again
    dt.decoded.fill <- dt.decoded[fuel_type %in% c('I','L'),.(batterysize_fill=mean(batterysize,na.rm=T)),
                                        by=c('model_year','make','model','fuel_type','body_type','drive_type')]
    dt.decoded <- merge(dt.decoded,dt.decoded.fill,
                          by=c('model_year','make','model','fuel_type','body_type','drive_type'),
                          all.x=T)
    dt.decoded[is.na(batterysize) & !is.na(batterysize_fill),batterysize:=batterysize_fill]
    # match remaining missing trim on make/model/fuel type
    dt.battery.model <- dt.battery[,.(batterysize=mean(batterysize,na.rm=T)),
                                  by=c('model_year','make','model','fuel_type')]
    dt.unmatched <- dt.decoded[fuel_type %in% c('I','L') & is.na(batterysize)]
    dt.unmatched <- merge(dt.unmatched[,!c('batterysize')],
                          dt.battery.model,
                          by=c('model_year','make','model','fuel_type'),
                          all.x=T)
    # add back to dt.ct.decoded
    dt.decoded <- rbind(dt.decoded[!(is.na(batterysize) & fuel_type %in% c('I','L'))],dt.unmatched)
    dt.decoded <- dt.decoded[,!c('batterysize_fill'),with=F]
    
    # fill in missing model (wasn't in range data because the VIN doesn't show up in Experian VIN data)
    dt.decoded[is.na(batterysize) & make == 'Mercedes' & model == 'S-Class' & fuel_type == 'I', batterysize:=13.5]
    
    # 0 out non electric vehicles
    dt.decoded[is.na(batterysize) & !(fuel_type %in% c('L','I')),batterysize:=0]
    unique(dt.decoded[is.na(batterysize),.(model_year, make, model, fuel_type)])
    
    ### merge decoded data with ZEV credits ----
    # need to do first merge on everything, then second merge on make/model/model_year/fuel_type
    dt.decoded <- merge(dt.decoded,
                      dt.zev.credits,
                      by=c('make','model','model_year','trim','style','body_type','drive_type','fuel_type'),
                      all.x=T)
    
    # second merge
    dt.zev.credits.model <- unique(dt.zev.credits[,.(make,model,model_year,fuel_type,zev_credits,UDDS_AER_mi,UDDS_AER_mi_pred,UDDS_EAER_mi,EAER_mi_pred)])
    dt.zev.credits.model <- dt.zev.credits.model[,.(zev_credits_fill=mean(zev_credits),
                                                    UDDS_AER_mi_fill = mean(UDDS_AER_mi,na.rm=T),
                                                    UDDS_AER_mi_pred_fill = mean(UDDS_AER_mi_pred,na.rm=T),
                                                    UDDS_EAER_mi_fill = mean(UDDS_EAER_mi,na.rm=T),
                                                    EAER_mi_pred_fill = mean(EAER_mi_pred,na.rm=T),
                                                    ct=.N),by=c('make','model','model_year','fuel_type')]
    dt.decoded <- merge(dt.decoded,
                      dt.zev.credits.model[,!c('ct'),with=F],
                      by=c('make','model','model_year','fuel_type'),
                      all.x=T)
    dt.decoded[is.na(zev_credits) & !is.na(zev_credits_fill),
              `:=`(zev_credits=zev_credits_fill,
                    UDDS_AER_mi=UDDS_AER_mi_fill,
                    UDDS_AER_mi_pred=UDDS_AER_mi_pred_fill,
                    UDDS_EAER_mi=UDDS_EAER_mi_fill,
                    EAER_mi_pred=EAER_mi_pred_fill)]
    unique(dt.decoded[is.na(zev_credits) & fuel_type %in% c('L','I'),.(make,model,model_year)])
    unique(dt.decoded[is.na(UDDS_AER_mi) & is.na(UDDS_AER_mi_pred) & is.na(UDDS_EAER_mi) & is.na(EAER_mi_pred) & fuel_type %in% c('L','I'),.(make,model,model_year)])
    
    dt.decoded <- dt.decoded[,!c('zev_credits_fill','UDDS_AER_mi_fill','UDDS_AER_mi_pred_fill','UDDS_EAER_mi_fill','EAER_mi_pred_fill'),with=F]
    # fill in NAs as 0
    dt.decoded[is.na(zev_credits),zev_credits:=0]
    
    ### choose the lowest cost sp_id, and break ties using trim name ----
    setorderv(dt.decoded,cols = c('model_year','make','model', 'msrp','trim'),order=1L)
    dt.decoded.keep <- dt.decoded[!duplicated(dt.decoded$sp_id),]
    dt.decoded.keep <- dt.decoded.keep[!is.na(vin_pattern)]
    
    ### merge decoder with sales data ----
    setnames(dt.sales,c('make','model','model_year'),c('sp_make','sp_model','sp_model_year'))
    if(state == 'CT')
    {
      dt.sales <- merge(dt.sales[,.(sp_make,sp_model,sp_model_year,report_year_month,transaction_price,zip_code,county_name,state_abbrv,veh_count,sp_id)],
                        dt.decoded.keep[,!c('make_sp','model_sp')],
                        by=c('sp_id'),
                        all.x=T)
    } else
    {
      dt.sales <- merge(dt.sales[,.(sp_make,sp_model,sp_model_year,report_year_month,transaction_price,county_name,state_abbrv,veh_count,sp_id)],
                        dt.decoded.keep[,!c('make_sp','model_sp')],
                        by=c('sp_id'),
                        all.x=T)
    }
  }
  # fix a weird observation from VIN decoder (doing this late so it doesn't have to be fixed everywhere)
  dt.sales[make == 'Wagoneer',make:= 'Jeep']

  # convert transaction price to 1000s
  dt.sales[,transaction_price:=transaction_price/1000]

  # drop non-decoded obs
  # note: missing many 2023 model year vehicles from VIN decoder
  dt.sales.missing <- dt.sales[is.na(msrp)]
  unique(dt.sales.missing[sp_model_year <= 2022,.(sp_make,sp_model)])[1:40]
  dt.sales <- dt.sales[!is.na(msrp)]

  # convert report year month to date format
  dt.sales[,report_dt:=as.Date(paste0(report_year_month,'01'),'%Y%m%d')]

  # if using pre-cleaned data, multiply range back by 10
  if(bln.vindata)
  {
    dt.sales[,range_elec:=range_elec*10]
  }

  # add policy info ----
  ## ZEV credits ----
  # need a column that indicates if ZEV credits apply in state
  dt.sales[,zev_state:=0]
  dt.sales[state_abbrv %in% c('CA','NY','MA','NJ','CT'),zev_state:=1]

  ## state incentives ----
  msrp_buffer <- 1
  # note: range amounts are divided by 10
  # when policy changes mid-month, use higher/less stringent incentive

  dt.sales[,state_incentive:=0]
  if (state == 'CT')
  {
    ### CT ----
    dt.sales[,dealer_incentive:=0]
    # Aug 2017 - Oct 14 2018 policy
    dt.sales[state_abbrv == 'CT' & report_dt >= as.Date('2018-01-01') & report_dt < as.Date('2018-11-01') & msrp <= 60 + msrp_buffer & fuel_type == 'L',
              state_incentive:=ifelse(range_elec >= 175, 3,
                                      ifelse(range_elec >= 100, 2,
                                            .5))]
    dt.sales[state_abbrv == 'CT' & report_dt >= as.Date('2018-01-01') & report_dt < as.Date('2018-11-01') & msrp <= 60 + msrp_buffer  & fuel_type == 'I',
              state_incentive:=ifelse(range_elec >= 40, 2, .5)]
    dt.sales[state_abbrv == 'CT' & report_dt >= as.Date('2018-01-01') & report_dt < as.Date('2018-11-01') & state_incentive > 0 & make != 'Tesla',
            dealer_incentive:= .15]
    # Oct. 14 2018 - Oct. 14 2019
    dt.sales[state_abbrv == 'CT' & report_dt > as.Date('2018-10-01') & report_dt < as.Date('2019-11-01') & msrp <= 50 + msrp_buffer  & fuel_type == 'L',
              state_incentive:=ifelse(range_elec >= 200, 2,
                                      ifelse(range_elec >= 120, 1.5,
                                            .5))]
    dt.sales[state_abbrv == 'CT' & report_dt > as.Date('2018-10-01') & report_dt < as.Date('2019-11-01') & msrp <= 50 + msrp_buffer  & fuel_type == 'I',
              state_incentive:=ifelse(range_elec >= 45, 1,.5)]
    dt.sales[state_abbrv == 'CT' & report_dt > as.Date('2018-10-01') & report_dt < as.Date('2019-11-01') & state_incentive > 0 & make != 'Tesla',
            dealer_incentive:= .15]
    # Oct. 15 2019 - June 6 2021
    dt.sales[state_abbrv == 'CT' & report_dt > as.Date('2019-10-01') & report_dt < as.Date('2021-06-01') & msrp <= 42 + msrp_buffer  & fuel_type == 'L',
              state_incentive:=ifelse(range_elec >= 200, 1.5,.5)]
    dt.sales[state_abbrv == 'CT' & report_dt > as.Date('2019-10-01') & report_dt < as.Date('2021-06-01') & msrp <= 42 + msrp_buffer  & fuel_type == 'I',
              state_incentive:=.5]
    dt.sales[state_abbrv == 'CT' & report_dt > as.Date('2019-10-01') & report_dt < as.Date('2021-06-01') & state_incentive > 0 & make != 'Tesla',
            dealer_incentive:= ifelse(range_elec >= 200, .125, .075)]
    # June 6 2021 - June 30, 2022
    dt.sales[state_abbrv == 'CT' & report_dt > as.Date('2021-05-01') & report_dt < as.Date('2022-07-01') & msrp <= 42 + msrp_buffer  & fuel_type == 'L',
              state_incentive:=2.25]
    dt.sales[state_abbrv == 'CT' & report_dt > as.Date('2021-05-01') & report_dt < as.Date('2022-07-01') & msrp <= 42 + msrp_buffer  & fuel_type == 'I',
              state_incentive:=.75]
    dt.sales[state_abbrv == 'CT' & report_dt > as.Date('2021-05-01') & report_dt < as.Date('2022-07-01') & state_incentive > 0 & make != 'Tesla',
            dealer_incentive:= ifelse(fuel_type == 'L',.125, .075)]
    # July 1 2022 - Dec. 31 2022
    dt.sales[state_abbrv == 'CT' & report_dt >= as.Date('2022-07-01') & report_dt < as.Date('2023-01-01') & msrp <= 50 + msrp_buffer & fuel_type == 'L',
              state_incentive:=2.25]
    dt.sales[state_abbrv == 'CT' & report_dt >= as.Date('2022-07-01') & report_dt < as.Date('2023-01-01') & msrp <= 50 + msrp_buffer  & fuel_type == 'I',
              state_incentive:=.75]
    dt.sales[state_abbrv == 'CT' & report_dt >= as.Date('2022-07-01') & report_dt < as.Date('2023-01-01') & state_incentive > 0 & make != 'Tesla',
            dealer_incentive:= ifelse(fuel_type == 'L',.125, .075)]
    #unique(dt.ct.zip[fuel_type %in% c('L','I') & state_incentive == 0,.(report_dt,make,model,msrp,model_year)])
    #dt.ct.decoded[model == 'S90' & model_year == 2018]
    
    # Tesla ineligibility issue
    dt.sales[make == 'Tesla' & report_dt >= as.Date('2021-11-01') & report_dt < as.Date('2022-07-01') & state_incentive > 0,state_incentive:= 0]
  } else
  {
    ### CA ----
    # Nov. 2016 - end of 2019: EVs $2500, PHEVs UDDS AER > 20
    dt.sales[,UDDS_measure:=ifelse(!is.na(UDDS_AER_mi),UDDS_AER_mi,
                                  ifelse(!is.na(UDDS_EAER_mi),UDDS_EAER_mi,
                                          ifelse(!is.na(UDDS_AER_mi_pred),UDDS_AER_mi_pred,
                                                EAER_mi_pred)))]
    
    dt.sales[state_abbrv == 'CA' & substr(report_year_month,1,4) %in% c('2018','2019') & fuel_type == 'L',
            state_incentive:=2.5]
    dt.sales[state_abbrv == 'CA' & substr(report_year_month,1,4) %in% c('2018','2019') & fuel_type == 'I',
            state_incentive:=ifelse(UDDS_measure>20,1.5,0)]
    # 2020 on 
    dt.sales[state_abbrv == 'CA' & substr(report_year_month,1,4) %in% c('2020','2021','2022') & fuel_type == 'L' & msrp < 60 + msrp_buffer,
            state_incentive:=2]
    dt.sales[state_abbrv == 'CA' & report_dt >= as.Date('2020-01-01') & report_dt < as.Date('2021-04-01') & fuel_type == 'I' & msrp < 60 + msrp_buffer,
            state_incentive:=ifelse(UDDS_measure >= 35, 1,0)]
    dt.sales[state_abbrv == 'CA' & report_dt >= as.Date('2021-04-01') & fuel_type == 'I' & msrp < 60 + msrp_buffer,
            state_incentive:=ifelse(range_elec > 30, 1,0)]
    # zero out a few weird missing data EVs
    dt.sales[state_abbrv == 'CA' & is.na(state_incentive),state_incentive:=0]
    ### NJ ----
    # Jan. 17, 2020 - Dec. 15, 2020
    dt.sales[state_abbrv == 'NJ' & report_dt >= as.Date('2020-01-01') & report_dt < as.Date('2021-01-01') & msrp <= 55 + msrp_buffer,
            state_incentive:=pmin(range_elec*25/100,5)]
    # July 2021 - Sept. 15, 2021
    dt.sales[state_abbrv == 'NJ' & report_dt >= as.Date('2021-07-01') & report_dt < as.Date('2021-10-01') & msrp <= 45 + msrp_buffer,
            state_incentive:=pmin(range_elec*25/100,5)]
    dt.sales[state_abbrv == 'NJ' & report_dt >= as.Date('2021-07-01') & report_dt < as.Date('2021-10-01') & (msrp > 45 + msrp_buffer) & (msrp <= 55 + msrp_buffer),
            state_incentive:=pmin(range_elec*25/100,2)]
    # July 2022 - Dec. 31, 2022
    dt.sales[state_abbrv == 'NJ' & report_dt >= as.Date('2022-07-01') & report_dt < as.Date('2023-01-01') & msrp <= 45 + msrp_buffer,
            state_incentive:=pmin(range_elec*25/100,4)]
    dt.sales[state_abbrv == 'NJ' & report_dt >= as.Date('2022-07-01') & report_dt < as.Date('2023-01-01') & (msrp > 45 + msrp_buffer) & (msrp <= 55 + msrp_buffer),
            state_incentive:=pmin(range_elec*25/100,2)]
    ### TX ----
    # June 2018 - March 28, 2019
    dt.sales[state_abbrv == 'TX' & report_dt >= as.Date('2018-06-01') & report_dt < as.Date('2019-04-01') & batterysize >= 4 & make != 'Tesla',
            state_incentive:=2.5]
    # Sept. 2019 - Jan. 7, 2021
    dt.sales[state_abbrv == 'TX' & report_dt >= as.Date('2019-09-01') & report_dt < as.Date('2021-02-01') & batterysize >= 4 & make != 'Tesla',
            state_incentive:=2.5]
    # Sept. 2021 - July 2022
    dt.sales[state_abbrv == 'TX' & report_dt >= as.Date('2021-09-01') & report_dt < as.Date('2022-08-01') & batterysize >= 4 & make != 'Tesla',
            state_incentive:=2.5]
    ### NY ----
    # 2017 - June 30, 2021
    dt.sales[state_abbrv == 'NY' & report_dt >= as.Date('2018-01-01') & report_dt < as.Date('2021-07-01') & fuel_type %in% c('I','L') & msrp > 60 + msrp_buffer,
            state_incentive:=0.5]
    dt.sales[state_abbrv == 'NY' & report_dt >= as.Date('2018-01-01') & report_dt < as.Date('2021-07-01') & fuel_type %in% c('I','L') & 
              msrp <= 60 + msrp_buffer,
            state_incentive:=ifelse(range_elec >= 120, 2, ifelse(range_elec >= 40, 1.7, ifelse(range_elec >= 20, 1.1, 0.5) ))]
    # July 1, 2021 - present (last checked 9/23)
    dt.sales[state_abbrv == 'NY' & report_dt >= as.Date('2021-07-01') & fuel_type %in% c('I','L') & msrp > 42 + msrp_buffer,
            state_incentive:=0.5]
    dt.sales[state_abbrv == 'NY' & report_dt >= as.Date('2021-07-01') & fuel_type %in% c('I','L') & msrp <= 42 + msrp_buffer,
            state_incentive:=ifelse(range_elec >= 200, 2, ifelse(range_elec >= 40, 1, 0.5))]
    ### PA ----
    # Sept. 2017 - Aug. 31, 2018
    dt.sales[state_abbrv == 'PA' & report_dt >= as.Date('2017-09-01') & report_dt < as.Date('2018-09-01') & msrp <= 50 + msrp_buffer,
            state_incentive:=ifelse(batterysize >= 20, 1.75,
                                    ifelse(batterysize >= 10, 1, 0.75))]
    # Sept 1, 2018 - June 30, 2019
    dt.sales[state_abbrv == 'PA' & report_dt >= as.Date('2018-09-01') & report_dt < as.Date('2019-07-01') & msrp <= 50 + msrp_buffer,
            state_incentive:=ifelse(batterysize >= 85, 2,
                                    ifelse(batterysize >= 10, 1, 0.75))]
    # July 1, 2019 - Feb. 2020
    dt.sales[state_abbrv == 'PA' & report_dt >= as.Date('2019-07-01') & report_dt < as.Date('2020-03-01') & fuel_type %in% c('L','I') & msrp <= 50 + msrp_buffer,
            state_incentive:=ifelse(fuel_type == 'L',1.5,1)]
    
    # March 2020 - Aug. 31, 2022
    dt.sales[state_abbrv == 'PA' & report_dt >= as.Date('2020-03-01') & report_dt < as.Date('2022-09-01') & fuel_type %in% c('L','I') & msrp <= 50 + msrp_buffer,
            state_incentive:=ifelse(fuel_type == 'L',0.75,0.5)]
    ### MA ----
    # 2018
    dt.sales[state_abbrv == 'MA' & substr(report_year_month,1,4) == '2018' & fuel_type == 'L',
            state_incentive:=2.5]
    dt.sales[state_abbrv == 'MA' & substr(report_year_month,1,4) == '2018' & fuel_type == 'I',
            state_incentive:=ifelse(batterysize >= 10, 2.5, 1.5)]
    # 2019
    dt.sales[state_abbrv == 'MA' & substr(report_year_month,1,4) == '2019' & fuel_type == 'L',
            state_incentive:=1.5]
    # 2020 - 2022
    dt.sales[state_abbrv == 'MA' & substr(report_year_month,1,4) %in% c('2020','2021','2022') & msrp <= 50+msrp_buffer,
            state_incentive:=ifelse(fuel_type == 'L',2.5,
                                    ifelse(fuel_type == 'I' & range_elec >= 25, 1.5,0))]
  }


  ## federal tax credits ----
  dt.sales <- merge(dt.sales,dt.fed.nonphaseout,
                    by=c('make','model','fuel_type','model_year'),
                    all.x=T)
  dt.sales <- merge(dt.sales,dt.fed.phaseout,
                    by=c('make','model','fuel_type','model_year'),
                    all.x=T)
  dt.sales[fuel_type %in% c('L','I') & is.na(fed_credit) & is.na(L2.Start) & model_year < 2021,.(make,model,model_year)]

  # for credits that phaseout, choose correct credit amount based on purchase month
  dt.sales[!is.na(L2.Start),fed_credit:=ifelse(report_dt < L2.Start,L1,
                                            ifelse(report_dt < L3.Start,L2,
                                                  ifelse(report_dt < Final.Start,L3,Final)))]
  dt.sales <- dt.sales[,!c('L2.Start','L3.Start','Final.Start','L1','L2','L3','Final'),with=F]
  dt.sales[is.na(fed_credit),fed_credit:=0]

  # rescale federal credits to 1000s of dollars to be consistent with other data
  dt.sales[,fed_credit:=fed_credit/1000]

  # save data ----
  if(state == 'CT')
  {
    write.csv(dt.sales,
              paste0(str.sp,'ct_decoded_full_attributes.csv'),
              row.names=F)
  } else
  {
    write.csv(dt.sales,
              paste0(str.sp,'top15_decoded_full_attributes.csv'),
              row.names=F)
    # keep only the subset of states that don't have state incentives
    vec.state.pol <- unique(dt.sales[state_incentive != 0,state_abbrv])
    dt.nopol <- dt.sales[!(state_abbrv %in% vec.state.pol)]
    write.csv(dt.nopol,
              paste0(str.sp,'nostatepol_decoded_full_attributes.csv'),
              row.names=F)
  }
}
if(FALSE){
  ## add noise ----
  if(state == 'CT')
  {
    dt.noise <- dt.sales
  } else
  {
    dt.noise <- dt.nopol
  }
  # get sd of transaction price
  sd_factor <- 10
  sd_sample <- mean(dt.noise$transaction_price,na.rm=T)
  vec_noise <- rnorm(nrow(dt.noise),mean=0,sd=sd_sample/sd_factor)
  dt.noise[,transaction_price_noise:=transaction_price + vec_noise]
  #dt.noise[transaction_price_noise < 0,.(transaction_price,transaction_price_noise)]
  if(state == 'CT')
  {
    write.csv(dt.noise[,!c('transaction_price','UDDS_AER_mi','UDDS_AER_mi_pred','UDDS_EAER_mi','EAER_mi_pred'),with=F],
              paste0(str.noise,'ct_decoded_full_attributes.csv'),
              row.names=F)
  } else
  {
    write.csv(dt.noise[,!c('transaction_price','UDDS_AER_mi','UDDS_AER_mi_pred','UDDS_EAER_mi','EAER_mi_pred'),with=F],
              paste0(str.noise,'nostatepol_decoded_full_attributes.csv'),
              row.names=F)  
  }

  ## summary stats, real data ----
  dt.sales[,.(mean = mean(transaction_price,na.rm=T),min=min(transaction_price,na.rm=T),
              pctile_10 = quantile(transaction_price, .1,na.rm=T),pctile_90 = quantile(transaction_price,.9,na.rm=T),
              max=max(transaction_price,na.rm=T),sd = sd(transaction_price,na.rm=T)),by=c('fuel')]
}

